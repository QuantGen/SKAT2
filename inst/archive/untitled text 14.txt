##testing
#library(BGLR)
#data(mice)
#fast1=getFaST(y=mice.pheno$Obesity.BMI,Z=list(Z1=mice.X[,1:20]))
#updateFaST.Zt(fast1,Zt=mice.X[,20:22])
#updateFaST.Zw(fast1,list(mice.X[,1:2]))

getFaST = function(y, X = NULL, Z = NULL, Zt = NULL) {
	out = list()
	#initialize everything to NULL
	U1 = d1 = n = nd= tU1y = tU1X = tXX = tyy =  listZw  = Zw = kw = tU1W = tXW = tWy = tWW = tU1Zt = tXZt = tyZt = tZtZt = tWZt = NULL
	nw = 0
	if (is.null(X)) {
		X = matrix(rep(1, length(y)))
	}
	whichNa = which(is.na(y))
	if (length(whichNa) > 0) {
		y = y[-whichNa]
		X = X[-whichNa, , drop = F]
	}
	if (!is.null(Z)) {
		if (!("eigenG" %in% class(Z[[1]]))) {
			cat("It is better to supply the first element of Z as an eigenG object to save computation\n")
			eigenG = getEigenG(Zg = Z[[1]])
		} else {
			eigenG = Z[[1]]
		}
		if (length(whichNa) > 0) {
			eigenG$U1 = eigenG$U1[-whichNa, ]
		}
		if (length(Z) > 1) {
			listZw = Z[-1]
			if (length(whichNa) > 0) {
				listZw = lapply(listZw, function(a){a[-whichNa, , drop = F]})
			}
			kw = sapply(listZw, ncol)
			nw = length(kw)
			Zw = do.call(cbind, Zw)
		}
		
		X = as.matrix(X)
		n = length(y)
		U1 = eigenG$U1
		d1 = eigenG$d1
		nd=length(d1)
		tU1X = crossprod(U1, X)
		tU1y = crossprod(U1, y)
		if (nd < n) {
			tXy = crossprod(X, y)
			tXX = crossprod(X)
			tyy = sum(y^2)
		}



		if (!is.null(Zw)) {
			tauw = rep(0, nw)
			tU1W = crossprod(U1, Zw)
			if (nd < n) {
				tXW = crossprod(X, Zw)
				tWW = crossprod(Zw)
				tWy = crossprod(Zw, y)
				if (!is.null(Zt)) {
					tWZt = crossprod(Zw, Zt)
				}
			}
		}


		if (!is.null(Zt)) {
			varXt = apply(Zt, 2, function(a) var(a, na.rm = T))
			whichVar = which(varXt > 0)
			if (length(whichVar) > 0) {
				Zt = Zt[, whichVar, drop = F]
			} else {
				warning("No variants in Zt")
				Zt = NULL
			}
			if (!is.null(Zt)) {
				tU1Zt = crossprod(U1, Zt)
				if (nd < n) {
					tyZt = crossprod(y, Zt)
					tXZt = crossprod(X, Zt)
					tZtZt = crossprod(Zt)
				}
			}
		}
##currently suppress the tauRel otpion
#		namesPar = c("var_e", "taud")
#		if (nw > 0) {
#			namesPar = c("var_e", "taud", paste("tauw", c(1:nw), sep = ""))
#			namesParReduced = updateNames_tauRel(namesPar, tauRel)
#		}
#		Var = rep(0.5, length(namesPar))
#		VarReduced = rep(0.5, length(namesParReduced))
#		names(Var) = namesPar
#		names(VarReduced) = namesPar
#end of option for tauRel

	}

	out$y = y
	out$X = X
	out$whichNa = whichNa
	out$U1 = U1
	out$d1 = d1
	out$n = n
	out$nd=nd
	out$tU1y = tU1y
	out$tU1X = tU1X
	out$tXX = tXX
	out$tXy = tXy
	out$tyy = tyy
	out$listZw = listZw 
	out$Zw = Zw
	out$kw = kw
	out$nw = nw
	out$tU1W = tU1W
	out$tXW = tXW
	out$tWW = tWW
	out$tWy = tWy
	out$Zt = Zt
	out$tU1Zt = tU1Zt
	out$tXZt = tXZt
	out$tyZt = tyZt
	out$tWZt = tWZt
	out$tZtZt = tZtZt
	#Currently suprress the tauRel option
	#out$VarReduced = VarReduced
	#out$tauRel = tauRel
	class(out) = c("FaST")
	return(out)
}

updateFaST.Zw = function(FaST, listZw) {
	kw = sapply(listZw, ncol)
	nw = length(kw)
	Zw = do.call(cbind, listZw)
	eval.parent(substitute({
	FaST[["listZw"]]=listZw 
	FaST[["Zw"]] = Zw
	FaST[["kw"]] = kw
	FaST[["nw"]]= nw
	if (!is.null(FaST$U1)) 
		FaST[["tU1W"]] = crossprod(FaST$U1, Zw)
	if (FaST$nd < FaST$n) {
		FaST[["tXW"]] = crossprod(FaST$X, Zw)
		FaST[["tWW"]] = crossprod(Zw)
		FaST[["tWy"]] = crossprod(Zw, FaST$y)
		if (!is.null(FaST$Zt)) 
			FaST[["tWZt"]] = crossprod(Zw, FaST$Zt)
	}
	}
	)
	)
}


updateFaST.X = function(FaST, X) {
	eval.parent(substitute({
		FaST[["X"]] = X
		if (!is.null(FaST$tU1X)) {
			FaST[["tU1X"]] = crossprod(FaST$U1, X)
		}

		if (!is.null(FaST$tXX)) {
			FaST[["tXX"]] = crossprod(X)
		}
		if (!is.null(FaST$tXy)) {
			FaST[["tXy"]] = crossprod(X, FaST$y)
		}
		if (!is.null(FaST$tXW)) {
			FaST[["tXW"]] = crossprod(X, FaST$Zw)
		}
		if (!is.null(FaST$tXZt)) {
			FaST[["tXZt"]] = crossprod(X, FaST$Zt)
		}
	}))
}

updateFaST.Zt = function(FaST, Zt) {
	varXt = apply(Zt, 2, function(a) var(a, na.rm = T))
	whichVar = which(varXt > 0)
	if (length(whichVar) > 0) {
		Zt = Zt[, whichVar, drop = F]
	} else {
		warning("No variants in Zt")
		Zt = NULL
	}
	eval.parent(substitute({
	FaST[['Zt']] = Zt
	if (!is.null(Zt)) {
		if (!is.null(FaST$U1)) {
			FaST$tU1Zt = crossprod(FaST$U1, Zt)
			if (FaST$nd < FaST$n) {
				FaST[['tyZt']] = crossprod(FaST$y, Zt)
				FaST[['tXZt']] = crossprod(FaST$X, Zt)
				FaST[['tZtZt']] = crossprod(Zt)
				if (!is.null(FaST$Zw)) {
					FaST[['tWZt']] = crossprod(FaST$Zw, Zt)
				}
			}
		}
	}
	}))
}



